---
title: "Soybean Yield Gap Analysis Clean Code"
author: "Sam Wallace"
date: "2025-01-31"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This markdown includes "clean", as in more direct code of the R code files in the Soybean_yga/Code folder for more centralized and cleaner use in analysis. R markdown is created by Sam Wallace

```{r Libraries,echo=F,results=F}
library(tidyverse)
library(emmeans)
library(lme4)
library(modelr)
library(ggpmisc)
library(lmerTest)
library(glmmTMB)
library(DHARMa)
library(shades)
library(MuMIn)
library(meta)
library(metafor)
library(here)
library(ggpubr)
library(performance)
library(janitor)
library(fitdistrplus)

options(contrasts = c("contr.sum", "contr.poly")) #setting contrasts
```

```{r Read in PRISM weather data}
#### PRISM weather data was extracted from python based API provided by Ben Eck from NRCC. The files here are raw data from there and are cleaned in this chunk.

PrismRaw2Clean <- function(csvpath, location){
  
  # Reads in raw file based on the file path including the file name and .csv. The here function is locating the r project location, so anything in the path will come after the project location in your file path.
  raw_prism = read_csv(here(csvpath))
  colnames(raw_prism) = c("date", "maxt", "mint", "prcp")
  raw_prism$date <- as.Date(raw_prism$date, format = "%m/%d/%Y")
  
  # This converts the english units from PRISM into metric and also finds the day of year for each entry.
  # Location input is the experimental site to use later in joins
  f_to_c <- 5/9
  clean_prism <- raw_prism %>%
    mutate(Year = year(date),
           doy = yday(date),
           maxt_c = (maxt-32)*f_to_c,
           mint_c = (mint-32)*f_to_c,
           prcp_cm = prcp*2.54,
           Location = rep(location ,nrow(raw_prism))) %>%
  dplyr::select(Year, date, doy, maxt_c, mint_c, prcp_cm, Location) %>%
    filter(Year > 1980)
  return(clean_prism)
}

# Now you can get your metric prism data for each location by just referencing the file path
musgrave_prism <- PrismRaw2Clean(csvpath = "R_data/Weather_data/PRISM/Raw_prism_files/musgrave_prism.csv", location = "Musgrave")
geneva_prism <- PrismRaw2Clean(csvpath = "R_data/Weather_data/PRISM/Raw_prism_files/geneva_prism.csv", location = "Geneva")
arlington_prism <- PrismRaw2Clean(csvpath = "R_data/Weather_data/PRISM/Raw_prism_files/arlington_prism.csv", location = "AARS")
psu_prism <- PrismRaw2Clean(csvpath = "R_data/Weather_data/PRISM/Raw_prism_files/psu_prism.csv", location = "Rock Springs")

write_csv(musgrave_prism, file = "R_data/Weather_data/PRISM/musgrave_prism_clean.csv")
write_csv(arlington_prism, file = "R_data/Weather_data/PRISM/arlington_prism_clean.csv")

```

```{r Precip normals graphs}
musgrave_2024 <- musgrave_prism %>%
  filter(Year == 2024,
         date >= "2024-05-01", # This was the start date of when I wanted to sum precipitation; if doing annual no need to filter down
         date <= "2024-11-15") %>%
  mutate(cum_rain = cumsum(prcp_cm)) # cumsum() function finds a cummulative sum of a column

musgrave_average <- musgrave_prism %>%
  mutate(day_month = format(date, "%m-%d"),
         doy = yday(date)) %>%
  filter(day_month >= "05-01" & day_month <= "11-15") %>% 
  group_by(doy) %>%
  arrange(date) %>%
  mutate(mean_prcp = mean(prcp_cm)) %>%
  ungroup() %>% 
  filter(Year == 2024) %>% # I put this year here so I could plot it against my other data with the same year
  mutate(avg_cum_rain = cumsum(mean_prcp))


primary_max <- max(musgrave_2024$prcp_cm)
sec_max <- max(musgrave_average$avg_cum_rain)
scale_factor <- sec_max/primary_max


mus_prcp_graph_2024 <- musgrave_2024 %>%
  ggplot(aes(x = date)) +
  theme_bw() +
  geom_bar(aes(y = prcp_cm, fill = "Daily rainfall (cm)"),stat = "identity") +
  scale_y_continuous(name = "Daily Rainfall (cm)",
    limits = c(0,primary_max),
    sec.axis = sec_axis(~.*scale_factor, name = "Cummulative rainfall (cm)")) +
  geom_line(aes(y = cum_rain/scale_factor, colour = "2024 cumulative"), linewidth = 1) +
  geom_line(data = musgrave_average,aes(x = date,y = avg_cum_rain/scale_factor, colour = "Long-term average"),
                                        linewidth = 1)+
  labs(y = "Daily rainfall (cm)", x = "Date", colour = "", fill = "") +
  scale_color_manual(values = c("2024 cumulative" = "black", "Long-term average" = "red")) +
  scale_fill_manual(values = c("Daily rainfall (cm)" = "gray")) +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        legend.position = "top",
        legend.text = element_text(size = 12)) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b",     
    expand = c(0, 0)          
  )
ggsave(mus_prcp_graph_2024, filename = "Figures/mus_prcp_2024.png", dpi = 300,
       width = 8, height = 5, units = "in")

arl_2024 <- arlington_prism %>%
  filter(Year == 2024,
         date >= "2024-05-01", # This was the start date of when I wanted to sum precipitation; if doing annual no need to filter down
         date <= "2024-11-15") %>%
  mutate(cum_rain = cumsum(prcp_cm)) # cumsum() function finds a cummulative sum of a column

arl_average <- arlington_prism %>%
  mutate(day_month = format(date, "%m-%d"),
         doy = yday(date)) %>%
  filter(day_month >= "05-01" & day_month <= "11-15") %>% # If doing annual I do not think you need to filter, but if you do just use start and end of year
  group_by(doy) %>%
  arrange(date) %>%
  mutate(mean_prcp = mean(prcp_cm)) %>%
  ungroup() %>% 
  filter(Year == 2024) %>% # I put this year here so I could plot it against my other data with the same year
  mutate(avg_cum_rain = cumsum(mean_prcp))


primary_max <- max(arl_2024$prcp_cm)
sec_max <- pmax(max(arl_average$avg_cum_rain), sum(arl_2024$prcp_cm))
scale_factor <- sec_max/primary_max


arl_prcp_graph_2024 <- arl_2024 %>%
  ggplot(aes(x = date)) +
  theme_bw() +
  geom_bar(aes(y = prcp_cm, fill = "Daily rainfall (cm)"),stat = "identity") +
  scale_y_continuous(name = "Daily Rainfall (cm)",
    limits = c(0,primary_max),
    sec.axis = sec_axis(~.*scale_factor, name = "Cummulative rainfall (cm)")) +
  geom_line(aes(y = cum_rain/scale_factor, colour = "2024 cumulative"), linewidth = 1) +
  geom_line(data = musgrave_average,aes(x = date,y = avg_cum_rain/scale_factor, colour = "Long-term average"),
                                        linewidth = 1)+
  labs(y = "Daily rainfall (cm)", x = "Date", colour = "", fill = "") +
  scale_color_manual(values = c("2024 cumulative" = "black", "Long-term average" = "red")) +
  scale_fill_manual(values = c("Daily rainfall (cm)" = "gray")) +
  theme(axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "top",
        legend.text = element_text(size = 14)) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b",     
    expand = c(0, 0)          
  )
ggsave(arl_prcp_graph_2024, filename = "Figures/arl_prcp_2024.png", dpi = 300,
       width = 8, height = 5, units = "in")
```

```{r Precipitation Frequency Analysis}
# Code to check 
prism_list <- list(musgrave_prism, arlington_prism, geneva_prism, psu_prism)

process_weather_data <- function(weather_data) {
  
  
  periods <- list(
  "1981 - 2002" <- 1981:2002,
  "2003 - 2024" <- 2003:2024
  )
  
  # Function to calculate annual maxima for each period
  calculate_annual_max <- function(year_range) {
    weather_data %>%
      filter(Year %in% year_range) %>%
      group_by(Year) %>%
      summarize(max_precip = max(prcp_cm*1.13, na.rm = TRUE))
  }
  
  # Get annual maxima for each period
  annual_max_list <- lapply(periods, calculate_annual_max)
  
  # Function to fit lognormal distribution and calculate return levels
  fit_lognormal <- function(annual_max) {
    annual_max <- annual_max$max_precip[annual_max$max_precip > 0]
    
    fit <- fitdist(annual_max, "lnorm")  # Fit lognormal distribution
    return(fit)
  }
  
  # Fit lognormal distribution to each period
  lognormal_fits <- lapply(annual_max_list, fit_lognormal)
  
  # Calculate return levels
  return_periods <- seq(5,100,5)
  
  calculate_return_levels <- function(fit) {
    # Extract parameters
    meanlog <- fit$estimate["meanlog"]
    sdlog <- fit$estimate["sdlog"]
    
    # Calculate return levels
    return_levels <- qlnorm(1 - (1 / return_periods), meanlog = meanlog, sdlog = sdlog)
    
    # Return levels as a data frame
    data.frame(
      Return_Period = return_periods,
      Return_Level = return_levels
    )
  }
  
  # Calculate return levels for each period
  return_levels_list <- lapply(lognormal_fits, calculate_return_levels)
  
  # Combine results into a single data frame for all periods
  return_levels_df <- bind_rows(
    data.frame(Period = "1981 - 2002", return_levels_list[[1]]),
    data.frame(Period = "2003 - 2024", return_levels_list[[2]]
  ))
  
  return(return_levels_df)
}

return_times_sites <- lapply(prism_list, process_weather_data)

combined_results <- bind_rows(
  lapply(seq_along(return_times_sites), function(i) {
    data.frame(Data_Set = paste("Data", i), return_times_sites[[i]])
  })
)

combined_results <- combined_results %>%
  mutate(site = case_match(Data_Set, 
                           "Data 1" ~ "Musgrave",
                           "Data 2" ~ "AARS",
                           "Data 3" ~ "Geneva",
                           "Data 4" ~ "Rock Springs"))

# Plot rainfall distributions of return times for each site and color dots by the time period
precip_freq <- combined_results %>%
  ggplot(aes(x = Return_Period, y = Return_Level, color = Period)) +
  geom_point() +
  geom_line() +
  facet_wrap(~site) + 
  theme_bw() +
  theme(legend.position = "top") +
  scale_color_manual(values = c("#1E88E5", "#FFC107")) +
  labs(y = "1-Day precipitation event (cm)",x = "Return period (Years)", color = "" ) +
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16))
ggsave(precip_freq, filename = here("Figures/prcp_freq_sites.png"),dpi = 300, width = 9, height = 6, units = "in")
```

```{r Read in soybean agronomic data}
# Read in all soybean data from raw file
soy_rye_raw <- read_csv(here("R_data/Soy_rye_data/NY_WI_NTvT_master.csv"))

# Select only rows that can be useful for further analysis
# Also editing experiment name for 2018 so I can model it differently
soy_rye_useful <- soy_rye_raw %>%
  mutate(ExperimentName = case_when(Field == "RN30" ~ "White Mold",
                                    Field == "RN20" ~ "White Mold",
                                    .default = ExperimentName)) %>%
  dplyr::select(Year, State, Location, ExperimentName, Rep, SoySeedingDate, Till_NT,
         RyeBiomass_kgha, SoyStand_ha, Per_Emergence, WeedBiomass_kgha, Yield_Mgha, Yield_buac, ExperimentalTrt, SoySeedingRate_ha) %>%
  filter(ExperimentName != "CIG NT Soybeans") %>%
  mutate(SoySeedingDate = as.Date(SoySeedingDate, format = "%m/%d/%y")) %>%
  filter(SoySeedingDate != "2019-10-06") %>%
  mutate(ExperimentName = case_when(SoySeedingDate == "2018-06-06"~ "No-Till Soy Split Plot",
                                    .default = ExperimentName),
         Location = case_when(State == "PA" ~ "Rock Springs", .default = Location)) %>%
  filter(State != "PA",
         Location != "Geneva")


# Count number of no-till and tilled plots for each experiment and year of the experiment
nt_t_counts <- soy_rye_useful %>%
  group_by(ExperimentName, Year) %>%
  mutate(nt_count = sum(Till_NT == "NT")) %>%
  mutate(till_count = sum(Till_NT == "Till")) %>%
  distinct(ExperimentName, till_count, nt_count)
```

```{r Function to get planting precipitation before and after}
#### These functions are for getting independent variables for later use in meta analysis, such as precip before and after planting, GDD, etc. These are variables that are climatically based and vary by site year
planting_precip <- function(met_df, mgmt_df, station_site){

  # met_df: Dataframe that includes precipitation data, year, and date at least to calculate precipitation around planting.
  # mgmt_df: Dataframe that includes soybean management and agronomic information, including planting date
  # station_site: String input for the name of experimental site (Musgrave, Arlington, Geneva, PSU, etc.)

# Find planting dates for the location for each experiment and year
  planting_dates <- mgmt_df %>%
    group_by(Year, Location) %>%
    slice_min(SoySeedingDate)%>%
    ungroup() %>%
    filter(Location == station_site) %>%
    dplyr::select(ExperimentName, Year, State, Location, SoySeedingDate) %>%
    distinct()
  
  exp_df <- left_join(met_df, planting_dates, by = c("Year","Location")) %>%
    mutate(plant_doy = yday(SoySeedingDate))
#### Calculates the precipitation +/- 15 days around planting period for each planting date at the site 
  plant_prcp <- exp_df %>%
    filter(!is.na(SoySeedingDate) & doy >= plant_doy - 15 & doy<= plant_doy + 15) %>%
    group_by(ExperimentName, Year, State, Location, SoySeedingDate) %>%
    summarise(plant_prcp = sum(prcp_cm, na.rm = T), .groups = "drop")
  return(plant_prcp)
}

#More functions to come depending on variables that we investigate, but format will be similar regardless of variable
musgrave_plant_prcp <- planting_precip(met_df = musgrave_prism, mgmt_df = soy_rye_useful, station_site = "Musgrave")
wi_plant_prcp <- planting_precip(met_df = arlington_prism, mgmt_df = soy_rye_useful, station_site = "AARS")
geneva_plant_prcp <- planting_precip(met_df = geneva_prism, mgmt_df = soy_rye_useful, station_site = "Geneva")
psu_plant_prcp <- planting_precip(met_df = psu_prism,
                                  mgmt_df = soy_rye_useful, 
                                  station_site = "Rock Springs")

all_plant_prcp <- rbind(musgrave_plant_prcp, wi_plant_prcp, geneva_plant_prcp, psu_plant_prcp)
comb_soy_prcp <- left_join(soy_rye_useful, all_plant_prcp, by = c("Year", "State", "Location", "ExperimentName"))
```

```{r Function to get rye biomass}
#### These functions are for getting independent variables for later use in meta analysis, such as precip before and after planting, GDD, etc. These are variables that are climatically based and vary by site year
rye_biomass <- function(mgmt_df, station_site){
  # mgmt_df: Dataframe that includes soybean management and agronomic information, including planting date

#### Finds rye biomass associated with a block for comparison of yields by tillage in differing levels of rye biomass
  rye_bm <- mgmt_df %>%
    group_by(ExperimentName, Year, State, Location, Rep) %>%
    mutate(rye_bm = ifelse(is.na(RyeBiomass_kgha), 
                           RyeBiomass_kgha[Till_NT == "NT"], 
                           RyeBiomass_kgha)) %>%
    summarise(rye_bm = mean(rye_bm, na.rm = TRUE)) %>%
    ungroup()

  return(rye_bm)
}

all_rye<- rye_biomass(soy_rye_useful)

mus_wi_rye <- all_rye %>%
  filter(Location %in% c("Musgrave", "AARS")) %>%
  drop_na() %>%
  group_by(Location, ExperimentName, Year) %>%
  summarise(rye_mean = mean(rye_bm)) %>%
  ungroup()

exps_w_rye <- mus_wi_rye$ExperimentName

soy_ylds <- soy_rye_useful %>%
  dplyr::select(ExperimentName, Year, State, Location, Rep, Till_NT, Yield_Mgha) %>%
  filter(ExperimentName %in% exps_w_rye)

comb_rye_prcp <- left_join(mus_wi_rye, soy_ylds,by = c("Year", "State", "ExperimentName", "Rep"))
```

```{r Function to get each experiments yield data set up for meta analysis}
get_model_inputs <- function(soy_data, experiment_name){
  # This function gets the data for each individual experiment to be used for creating each model
  model_input <- soy_data %>%
    filter(ExperimentName %in% experiment_name) %>%
    drop_na(Year) %>%
    mutate(Year = as.factor(Year)) %>%
    mutate(block = Rep)
}
 
experiment_names <- unique(comb_soy_prcp$ExperimentName)

# For loop below used to easily extract each dataframe for my experiments
input_list <- list()
for(i in 1:length(experiment_names)){
  input_list[[i]] <- get_model_inputs(comb_soy_prcp, experiment_names[i])
  clean_name <- gsub("[^a-zA-Z0-9]", "_", tolower(experiment_names[i]))
  df_name <- paste0(clean_name, "_inputs")
  assign(df_name, input_list[[i]])
}

# Data need to be further filtered by each experiment to only extract the "control" NT treatments and the tilled comparison. Experiments needing this are: Starter fert, seeding depth, coulter study, ccbrt, wisc. 2018, mowtivation, wi-2015.

sf_filter_inputs <- starter_fertilizer_study_inputs %>%
  filter(ExperimentalTrt == "Tilled" | ExperimentalTrt == "Control")
  
sd_filter_inputs <- seeding_depth_study_inputs %>%
  filter(ExperimentalTrt == "Tilled" | ExperimentalTrt == "1.75") # Need to figure out what seeding depth was used in tillage

#coulter_filter <- coulter_study_inputs %>%
 # filter(ExperimentalTrt == "Tilled no coulter" | ExperimentalTrt == "Straight coulter") # Talk to chris or ben about what coulter type to include
  
wi_2020 <- ccbrt_soybean_inputs %>%
  filter(Year == 2020 & (ExperimentalTrt == "Control" | endsWith(ccbrt_soybean_inputs$ExperimentalTrt,"r"))) # filter to only include the planter data, not drilled

wi_2019 <- ccbrt_soybean_inputs %>%
  filter(Year == 2019)

mowtivation_filter <- mowtivation_inputs %>%
  filter(ExperimentalTrt == "TIC" | ExperimentalTrt == "RNO")
  
wi_2015_filter <- no_till_soybeans_inputs %>%
  filter(startsWith(ExperimentalTrt, "Tilled") | startsWith(ExperimentalTrt, "0 "))

wi_2017_filter <- no_till_soybeans_inputs %>%
  filter(Year == 2017)

wi_2018 <- comb_soy_prcp %>%
  filter(ExperimentName == "No-Till Soy Split Plot") %>%
  separate_wider_delim(ExperimentalTrt, delim = " ", names = c("main_plot","split_plot")) %>%
  group_by(Rep,main_plot) %>%
  mutate(Yield_Mgha_2 = mean(Yield_Mgha))

wi_2018_mod <- lmer(log(Yield_Mgha) ~ main_plot*split_plot + (1|Rep:main_plot) + (1:Rep),
                    data = wi_2018)

wi_2018_filter <- comb_soy_prcp %>%
  filter(ExperimentName == "No-Till Soy Split Plot") %>%
  mutate(block = Rep)
summary(wi_2018_mod)
check_model(wi_2018_mod)
emmeans(wi_2018_mod, pairwise ~ split_plot|main_plot, type = "response")


combined_filtered_results <- rbind(barns_inputs, moss_inputs, sf_filter_inputs, sd_filter_inputs,
                                   coulter_study_inputs, wi_2020, wi_2019, mowtivation_filter,
                                   wi_2015_filter, wi_2017_filter, ocs_inputs, wi_2018_filter)
combined_filtered_results <- combined_filtered_results %>%
  mutate(Year = as.numeric(as.character(Year)),
         site_year = paste0(Location,"-",Year)) 
```

```{r T test of yields}
t_test_soy_yield <- combined_filtered_results %>%
  group_by(Year, Location) %>%
  summarize(t_test = list(t.test(Yield_Mgha ~ Till_NT))) %>%
  mutate(
    t_statistic = sapply(t_test, function(x) x$statistic),
    p_value = sapply(t_test, function(x) x$p.value),
    mean_tillage_1 = sapply(t_test, function(x) x$estimate[1]),
    mean_tillage_2 = sapply(t_test, function(x) x$estimate[2])
  )


soy_prcp_w_pvals <- left_join(combined_filtered_results, t_test_soy_yield)

soy_prcp_w_pvals <- soy_prcp_w_pvals %>%
  mutate(label = case_when(
      p_value < 0.05 & Till_NT == "Till"~ "*",
      p_value > 0.05 & Till_NT == "Till"~ "" ,
      !is.na(p_value) & Till_NT == "Till" ~ "*" 
    )
  ) %>%
  group_by(Year, Location, ExperimentName, Till_NT) %>%
  mutate(mean_yield = mean(Yield_Mgha)) %>%
  mutate(se_yield = sd(Yield_Mgha)/sqrt(n())) %>%
  ungroup() %>%
  distinct(Year, Location, ExperimentName, mean_yield, se_yield, p_value, label, Till_NT, site_year)

soy_prcp_w_pvals$Year[soy_prcp_w_pvals$Year == 2021 & soy_prcp_w_pvals$ExperimentName == "Seeding Depth Study"] <- "2021a" 
soy_prcp_w_pvals$Year[soy_prcp_w_pvals$Year == 2021 & soy_prcp_w_pvals$ExperimentName == "Starter Fertilizer Study"] <- "2021b" 



location_labels <- c("AARS" = "Arlington, WI", "Musgrave" = "Aurora, NY")

soy_pval_graph <- soy_prcp_w_pvals %>%
  ggplot(aes(x = Year, y = mean_yield, fill = Till_NT)) +
  geom_col(width = 0.6,  position = position_dodge(width = 0.6)) +
  geom_errorbar(aes(ymin = mean_yield-se_yield, ymax = mean_yield+se_yield), width = 0.2, position = position_dodge(width = 0.6)) +
  geom_text(aes(label = label, colour = "black", y = mean_yield+se_yield), size = 12, show.legend = FALSE, color = "black") +
  facet_wrap(~Location, nrow = 3, scales = "free_x", labeller = as_labeller(location_labels)) +
  scale_fill_manual(values = c("#3B528BFF", "#FDE779"), 
                    labels = c("NT" = "No-till", "Till" = "Till")) +
  theme_bw() +
  labs(y = expression(paste("Mean yield, " , "(kg ", " ", ha^{-1}, ")")),
       fill = "", 
       x = 'Year') +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14),
        axis.text.x = element_text(angle = 45, vjust = 0.7),
        strip.text = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14),
        legend.position = "top") 
ggsave(soy_pval_graph, filename = here("Figures/yield_by_tillage_pvals_metric.png"), dpi = 300, 
       width = 8, height = 5, units = "in")
```

```{r Seeing if Lmer on all data works}

combined_mixmod <- lmer(log(Yield_Mgha) ~ Till_NT*site_year + (1|Location:Year:block),
                        data = combined_filtered_results)
summary(combined_mixmod)
check_model(combined_mixmod)

comb_emm <- emmeans(combined_mixmod, pairwise~Till_NT|site_year, type = "response")

comb_contrasts <- as.data.frame(comb_emm$contrasts)

contrast_plus_data <- combined_filtered_results %>%
  left_join(comb_contrasts) %>%
  dplyr::select(Year, State, Location, ExperimentName, SoySeedingDate.y, ratio, SE, plant_prcp, site_year, Per_Emergence) %>%
  rename("SoySeedingDate" = SoySeedingDate.y,
         "yield_gap" = ratio) %>%
  distinct()

contrast_plus_data$SoySeedingDate[contrast_plus_data$ExperimentName == "Starter Fertilizer Study"] <- as.Date("2021-06-04", format = "%Y-%m-%d")
contrast_plus_data$plant_prcp[contrast_plus_data$ExperimentName == "Starter Fertilizer Study"] = 7.44



# Plot the output of the meta analysis
contrast_plus_data %>%
  ggplot(aes(x = plant_prcp, y = yield_gap))+
  geom_point(aes(color = State), size = 2) +
  geom_errorbar(aes(ymin = ci(yield_gap, SE)$lower, ymax = ci(yield_gap,SE)$upper, colour = State), width = 0.2) + # Error bars for CI
  #geom_text(aes(label  = site_year)) +
  labs(x = "Precipitation accumulation +/- 15 days of planting (cm)",
       y = "Ratio of no-till yield to tilled yield",
       color = "") +
  stat_poly_eq(formula = y~x, use_label(c("R2", "eq")), size = 5)+
  theme_pubr() +
  scale_color_manual(values = c("black", "red")) +
  geom_smooth(method = "lm",formula = y ~ x,  se = FALSE, color = "gray", 
              linetype = "dashed")  +
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16))
## Method seems to introduce a lot of standard error, but this could be due to how I am modeling

```

```{r Looking at stand count}
# Soybean density of NT treatments
filter_w_stand <- combined_filtered_results %>%
  filter(Till_NT == "NT") %>%
  group_by(Year, ExperimentName) %>%
  drop_na(SoyStand_ha) 

stand_w_prcp <- filter_w_stand %>%
  left_join(all_plant_prcp)

stand_model <- lmer(Yield_Mgha ~  Per_Emergence*plant_prcp + (1|ExperimentName:Year:Rep) + (1|ExperimentName:Year), 
                    data =stand_w_prcp)

summary(stand_model)
performance::r2(stand_model)

boxplot(filter_w_stand$Yield_Mgha)


filter_w_stand %>%
  #filter(as.numeric(SoySeedingRate_ha) <= 617500) %>%
  ggplot(aes(x = Per_Emergence, y = Yield_Mgha)) +
  geom_point() +
  facet_wrap(~SoySeedingRate_ha) +
  theme_pubr() +
  stat_poly_eq(method = "lm", formula = y ~ x + 0) +
  geom_smooth(method = "lm", formula = y ~ x + 0) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))

nrow(filter_w_stand %>%
  filter(as.numeric(SoySeedingRate_ha) <= 617500))
    
nt_all_vars <- stand_w_prcp %>%
  drop_na(RyeBiomass_kgha, WeedBiomass_kgha)

stand_prcp_mod <- lmer(Yield_Mgha ~  plant_prcp + (1|ExperimentName:Year:Rep) + (1|ExperimentName:Year), data = stand_w_prcp)
summary(stand_prcp_mod)
performance::r2(stand_prcp_mod)
stand_prcp_emm <- emtrends(stand_prcp_mod, var = "plant_prcp")
summary(stand_prcp_emm, infer = c(T,T))


stand_prcp_mod_nt <- lmer(Per_Emergence ~  plant_prcp + (1|ExperimentName:Year:Rep) + (1|ExperimentName:Year), data = stand_w_prcp)
summary(stand_prcp_mod_nt)
stand_prcp_emm_nt <- emtrends(stand_prcp_mod_nt, var = "plant_prcp")
summary(stand_prcp_emm_nt, infer = c(T))
performance::r2(stand_prcp_mod_nt)

soy_emg_plot <- filter_w_stand %>%
  ggplot(aes(x = Per_Emergence, y = Yield_Mgha)) +
  geom_point(size = 2, aes(colour = State)) +
  scale_color_manual(values = c("black", "red")) +
  theme_pubr()  +
  stat_poly_eq() +
  geom_smooth(method = "lm") +
  labs(y = "Soybean yield (Mg/ha)", x = "Percent emergence (%)", color = "") +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14))

ggsave(soy_emg_plot, filename = "Figures/soy_emg_plot.png", dpi = 300,
       width = 8, height = 5, units = "in")

 #### Looking into rye biomass with NT
soy_nt_rye <- combined_filtered_results %>%
  filter(Till_NT == "NT") %>%
  group_by(Year, ExperimentName, Rep) 

rye_yld_mod <- lmer(Yield_Mgha ~  RyeBiomass_kgha + (1|ExperimentName/Year/Rep), data = soy_nt_rye)

summary(rye_yld_mod)
performance::r2(rye_yld_mod) ### Super bad R^2 for just the rye biomass

library(scales)


soy_rye_yld <- soy_nt_rye %>%
  ggplot(aes(x =RyeBiomass_kgha, y = Yield_Mgha, color = State)) +
 # facet_wrap(~State, scales = "free") +
  geom_point(size = 2) +
  scale_color_manual(values = c("black", "red")) +
  theme_pubr()  +
  labs(y = "Soybean yield (Mg/ha)", x = "Cereal rye biomass at termination (kg/ha)", color = "") +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14))

ggsave(soy_rye_yld, filename = "Figures/soy_rye_yield_all.png", dpi = 300,
       width = 8, height = 5, units = "in")


ny_rye <- soy_nt_rye %>%
  filter(State == "NY") %>%
  ungroup() %>%
  dplyr::select(RyeBiomass_kgha)

wi_rye <- soy_nt_rye %>%
  filter(State == "WI") %>%
  ungroup() %>% 
  dplyr::select(RyeBiomass_kgha)


t.test(ny_rye$RyeBiomass_kgha, wi_rye$RyeBiomass_kgha, paired = F) # T test shows that the rye biomass is significantly different in WI than NY.

#### Looking at weed biomass

soy_nt_weeds <- soy_nt_rye %>%
  drop_na(WeedBiomass_kgha) %>%
  mutate(WeedBiomass_kgha = as.numeric(WeedBiomass_kgha))

soy_weed_mod <- lmer(Yield_Mgha ~  log(WeedBiomass_kgha+0.1) +  (1|ExperimentName/Year/Rep), data = soy_nt_weeds)

summary(soy_weed_mod)
check_model(soy_weed_mod)
performance::r2(soy_weed_mod)

nt_weed_plot <- soy_nt_weeds %>%
  ggplot(aes(x = WeedBiomass_kgha, y = Yield_Mgha)) +
  geom_point(aes(color = State)) +
  theme_pubr() +
  scale_color_manual(values = c("black", "red")) +
  labs(y = "Soybean yield (Mg/ha)", x = "Weed biomass (kg/ha)", color = "") +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14))

ggsave(nt_weed_plot, filename = "Figures/Soy_nt_weeds.png", dpi = 300,
       width = 8, height = 5, units = "in")


emg_crbm <- filter_w_stand %>%
  mutate(exp_year = paste(ExperimentName, Year)) %>%
  drop_na(RyeBiomass_kgha) %>%
  ggplot(aes(x = RyeBiomass_kgha, y = Per_Emergence)) +
  geom_point(size = 2, aes(colour = State)) +
  theme_pubr() +
  scale_color_manual(values = c("black", "red")) +
  geom_smooth(method = "lm") +
  stat_poly_eq(size = 5) +
  labs(y = "Soybean emergence (%)", x = "Cereal rye biomass at termination (kg/ha)", color = "") +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14))

ggsave(emg_crbm, filename = "Figures/Soy_emg_rye_bm.png", dpi = 300,
       width = 8, height = 5, units = "in")

emg_rye_mod <- lmer(Per_Emergence ~ RyeBiomass_kgha +  (1|ExperimentName:Year:Rep) + (1|ExperimentName:Year) + (1|ExperimentName), data = filter_w_stand)
check_model(emg_rye_mod)
performance::r2(emg_rye_mod)
summary(emg_rye_mod)



tot_model <- lmer(Yield_Mgha ~ RyeBiomass_kgha+plant_prcp+as.numeric(WeedBiomass_kgha)+Per_Emergence  + (1|ExperimentName:Year:Rep) , data = filter_w_stand)
check_model(tot_model)
performance::r2(tot_model)
summary(tot_model)

```

```{r Model the data}
get_soy_model <- function(soy_data, experiment_name, check_assumptions = TRUE){
  
  model_input <- soy_data %>%
    filter(ExperimentName %in% experiment_name) %>%
    drop_na(Year)
  
   exp_mod <- if(length(unique(soy_data$Year[soy_data$ExperimentName %in% experiment_name])) > 1){
        lmer(log(Yield_Mgha) ~ as.factor(Till_NT)*as.factor(Year) + (1|Year:block), data = model_input)
  } else{
    lmer(log(Yield_Mgha) ~ as.factor(Till_NT)*Year + (1|block), data = model_input)
  }
   
   if(check_assumptions){
    par(mfrow = c(2, 2))  # Arrange diagnostic plots
    
    # 1. Residuals vs Fitted - Check homoscedasticity
    plot(residuals(exp_mod) ~ fitted(exp_mod), 
         main = "Residuals vs Fitted",
         xlab = "Fitted Values", 
         ylab = "Residuals")
    abline(h = 0, col = "red")
    
    # 2. Normal Q-Q Plot - Check normality of residuals
    qqnorm(residuals(exp_mod), main = "Normal Q-Q")
    qqline(residuals(exp_mod), col = "red")
    
    # Check normality of random effects
    ranef_df <- ranef(exp_mod)
    qqnorm(unlist(ranef_df), main = "Random Effects Q-Q")
    qqline(unlist(ranef_df), col = "red")
  }
   
   mod_emm <- emmeans(exp_mod,pairwise ~Till_NT|as.factor(Year))
 
  contrast_df <- as.data.frame(mod_emm$contrasts) %>%
    dplyr::select(Year, estimate, SE) %>%
    mutate(ExperimentName = experiment_name) %>%
    rename(yield_gap = estimate)
  
  return(contrast_df)
}  
# Look at tweedie GLMM --> naturally allows variance to be non-consistent
library(nlme)
# Homogeneous variance model
model_hom <- lme(Yield_Mgha ~ Till_NT, random = ~ 1 | block, data = ocs_inputs)

# Heterogeneous variance model
model_het <- lme(Yield_Mgha ~ Till_NT,
                 random = ~ 1 | block,
                 weights = varIdent(form = ~ 1 | Till_NT),
                 data = ocs_inputs)

# Likelihood ratio test
anova(model_hom, model_het)
plot(resid(model_het)~predict(model_het))

emmeans(model_het, ~Till_NT)


barns_emm <- get_soy_model(combined_filtered_results, experiment_name = "BARNS", check_assumptions = T)
moss_emm <- get_soy_model(combined_filtered_results, experiment_name = "MOSS")
ocs_emm <- get_soy_model(combined_filtered_results, experiment_name = "OCS")
coulter_emm <- get_soy_model(combined_filtered_results, experiment_name = "Coulter Study")
sf_emm <- get_soy_model(combined_filtered_results, experiment_name = "Starter Fertilizer Study")
sd_emm <- get_soy_model(combined_filtered_results, experiment_name = "Seeding Depth Study")
mowtivation_emm <- get_soy_model(combined_filtered_results, experiment_name = "Mowtivation")
wi_nt_soy_emm <- get_soy_model(combined_filtered_results, experiment_name = "No-Till Soybeans")
wi_ccbrt_emm <- get_soy_model(combined_filtered_results, experiment_name = "CCBRT Soybean")
wi_2018_emm <- get_soy_model(combined_filtered_results, experiment_name = "No-Till Soy Split Plot")
#rose2_emm <- get_soy_model(comb_soy_prcp, experiment_name = "ROSE2")
#rose3_emm <- get_soy_model(comb_soy_prcp, experiment_name = "ROSE3")


# Combine all of the contrasts into one dataframe
total_contrasts <- rbind(barns_emm, moss_emm, ocs_emm,
                         mowtivation_emm, coulter_emm, sf_emm, sd_emm,
                         wi_nt_soy_emm, wi_ccbrt_emm, wi_2018_emm)#,
                        # rose2_emm, rose3_emm)
```

```{r Meta analysis work}
# Create inpput for meta analysis
meta_input <- combined_filtered_results %>%
  #mutate(Year = (Year)) %>%
  left_join(total_contrasts) %>%
  dplyr::select(Year, State, Location, ExperimentName, SoySeedingDate.y, yield_gap, SE, plant_prcp) %>%
  rename("SoySeedingDate" = SoySeedingDate.y) %>%
  mutate(site_year = paste0(State, "-", Year)) %>%
  distinct()

#meta_input <- left_join(meta_input, all_spring_gdd, by = c("Year", "State", "Location"))

#meta_input <- meta_input %>%
 # dplyr::select(-SoySeedingDate) %>%
#  rename("SoySeedingDate" = SoySeedingDate.y,
 #        "ExperimentName" = ExperimentName.x)

meta_input$SoySeedingDate[meta_input$ExperimentName == "Starter Fertilizer Study"] = as.Date("2021-06-04", format = "%Y-%m-%d")
meta_input$plant_prcp[meta_input$ExperimentName == "Starter Fertilizer Study"] = 7.44


meta_input %>%
  filter(State != "PA") %>%
  ggplot(aes(x = plant_prcp, y = exp(yield_gap))) +
  geom_point(aes(color = State))+
  #stat_poly_eq(formula = y~x, use_label(c("R2", "eq")), size = 5)+
  theme_pubr() +
  scale_color_manual(values = c("black", "slateblue", "red")) +
 # geom_smooth(method = "lm",formula = y ~ x,  se = FALSE, color = "gray", 
              #linetype = "dashed")  +
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16))
  

# Run the meta analysis
metagen_analysis <- metagen(data = meta_input, TE = yield_gap, seTE = SE, studlab = site_year)

# Save the results into this dataframe
metagen_result <- data.frame(
  effect_size = metagen_analysis$TE,  # Treatment effect
  ci_lower = metagen_analysis$lower,  # Lower bound of confidence interval
  ci_upper = metagen_analysis$upper,  # Upper bound of confidence interval
  i2 = metagen_analysis$I2            # I² for heterogeneity
)

# Combine with identifying data and rainfall data
metagen_result_comb <- cbind(metagen_result, meta_input)

# Transform the outputs to a linear scale from the log scale
metagen_result_final <- metagen_result_comb %>%
  mutate(yield_ratio = exp(yield_gap),
         lowerci_trans = exp(ci_lower),
         upperci_trans = exp(ci_upper)) #%>%
  #filter(site_year != "PA-2016" & site_year != "PA-2023" & site_year != "PA-2022")

# Plot the output of the meta analysis
ratio_yg_meta <- metagen_result_final %>%
  ggplot(aes(x = plant_prcp, y = yield_ratio))+
  geom_point(aes(color = State), size = 2) +
  geom_errorbar(aes(ymin = lowerci_trans, ymax = upperci_trans, colour = State), width = 0.2) + # Error bars for CI
  geom_text(aes(label  = site_year)) +
  labs(x = "Precipitation accumulation +/- 15 days of planting (cm)",
       y = "Ratio of no-till yield to tilled yield",
       color = "") +
  stat_poly_eq(formula = y~x, use_label(c("R2", "eq")), size = 5)+
  theme_pubr() +
  scale_color_manual(values = c("black", "red")) +
  geom_smooth(method = "lm",formula = y ~ x,  se = FALSE, color = "gray", 
              linetype = "dashed")  +
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16))
ggsave(ratio_yg_meta, filename = "Figures/ratio_yg_metaplot.png",dpi = 300,
       width = 9, height = 6, units = "in")


# Actual meta analysis work; above is simply just plotting effects from each lmer model against precipiation and getting an R squared value

metafor_metareg <- rma.mv(yi = effect_size, V = SE^2,
                          data = metagen_result_final, slab = ExperimentName,
                          random = ~ 1 |ExperimentName/site_year,
                          test = "t", method = "ML",
                          mods = ~ plant_prcp)
metafor_metareg

summary(metafor_metareg)
metafor_metareg


emm_meta <- emmprep(metafor_metareg)

prcp_values <- seq(min(metagen_result_final$plant_prcp), 
                   max(metagen_result_final$plant_prcp), 
                   length.out = 30)

em_out <- emmeans(emm_meta, ~plant_prcp, at = list(plant_prcp = prcp_values))
summary(em_out)

prcp_qdrg <- qdrg(object = metafor_metareg, data = metagen_result_final, at = list(prcp_values))
emmeans(prcp_qdrg, ~plant_prcp)
pred_meta <- predict(metafor_metareg, newmods = prcp_values)

pred_df <- data.frame(plant_prcp = prcp_values, 
                      predicted = exp(pred_meta$pred), 
                      SE = pred_meta$se, 
                      CI_low = exp(pred_meta$ci.lb), 
                      CI_high = exp(pred_meta$ci.ub))

pred_df %>%
  ggplot(aes(x = plant_prcp, y = predicted)) +
  geom_point() +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high)) +
  theme_bw()


fitted_vals <- predict(metafor_metareg)$pred

# Marginal R²: how much variance in observed values (yi) is explained by fixed effects
R2_marginal <- 1 - (var(residuals(metafor_metareg, type="response")) / var(metafor_metareg$yi))


new_data <- data.frame(plant_prcp = seq(min(metagen_result_final$plant_prcp), 
                                        max(metagen_result_final$plant_prcp), 
                                        length.out = 15))

pred <- predict(metafor_metareg, newmods = new_data$plant_prcp)

null_model <- rma.mv(yi = effect_size, V = SE^2, 
                     random = ~ 1 | ExperimentName/site_year,
                     data = metagen_result_final, method = "REML")

1-(metafor_metareg$QE/null_model$QE)

sigma2_metareg <- sum(metafor_metareg$sigma2)  
sigma2_null <- sum(null_model$sigma2)           

pseudo_r2 <- 1 - (sigma2_metareg / sigma2_null)
pseudo_r2 <- round(pseudo_r2, 3)

p_value <- metafor_metareg$pval[2]

new_data$pred <- exp(pred$pred)
new_data$ci.lb <- exp(pred$ci.lb)
new_data$ci.ub <- exp(pred$ci.ub)

# Plot the predictions with confidence intervals
metaplot <- ggplot(new_data_nlme, aes(x = plant_prcp, y = pred)) +
  geom_point(data = metagen_result_final, 
             aes(x = plant_prcp, y = yield_ratio, colour = State), 
             alpha = 0.95, size = 2) +
  geom_errorbar(data = metagen_result_final,
                aes(x = plant_prcp, y = yield_ratio,
                    ymin = lowerci_trans, ymax = upperci_trans, colour = State), width = 0.2) +
  annotate("text", x = 4, y=1.2, label = paste("R² =", round(pseudo_r2,3)), size = 5) +
  labs(x = "Precipitation +/- 15 days of planting (cm)", 
       y = "Ratio of no-till to tilled yield",
       color = "") +
  theme_pubr() +
  geom_line(data = new_data_nlme, aes(x = plant_prcp, y = predicted), color = "blue", size = 1, linetype = "dashed") +
  geom_smooth(method = "lm", formula = y ~ x
              ,data = metagen_result_final, aes(x = plant_prcp, y = yield_ratio)) +
  scale_color_manual(values = c("black", "red")) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14),
        plot.caption = element_text(size = 14),
        plot.caption.position = "plot",
        legend.position = "top") 

ggsave(metaplot, filename = "Figures/metaplot_w_points_nlme.png", dpi = 300,
       width = 9, height = 6, units = "in")

### Looking at non-linear function
library(nlme)
set.seed(123)

# Fit nonlinear model
fit <- nls(yield_ratio ~ L + (U - L) / (1 + exp(-k * (plant_prcp - x0))),
           data = metagen_result_final,
           start = list(L = 0.5, U = 1.1, k = 0.7, x0 = 8))
summary(fit)

group_data <- groupedData(yield_ratio~plant_prcp|as.factor(ExperimentName), data = metagen_result_final)

nlme_fit <- nlme(yield_ratio ~ L + (U - L) / (1 + exp(-k * (plant_prcp - x0))),
           data = group_data,
           start = c(L = 0.5, U = 1.1, k = 0.7, x0 = 8),
           fixed = L + U + k + x0 ~ 1,
           random = U ~ 1 |State,
           method = "ML")

plot(augPred(nlme_fit))
nlme::augPred(nlme_fit, data = getData(nlme_fit))

metagen_result_final$pred_group <- predict(nlme_fit, level = 1)

metagen_result_final %>%
  dplyr::select(ExperimentName, pred_fixed, pred_group, plant_prcp) %>%
  pivot_longer(cols = c(pred_fixed, pred_group), names_to = "pred", values_to = "value") %>%
  ggplot(aes(y = value, x = plant_prcp, color = pred)) +
  geom_point() +
  geom_line() +
  theme_pubr()



nlme_ran <- ranef(nlme_fit)$U
qqnorm(nlme_ran)
qqline(nlme_ran)



summary(nlme_fit)
check_model(nlme_fit)
new_data_nlme <- data.frame(
  plant_prcp = seq(min(metagen_result_final$plant_prcp),
                   max(metagen_result_final$plant_prcp),
                   length.out = 100),
  site_year = NA  # so random effect is not added
)
library(nlraa)

cor(predict(nlme_fit, level = 1), metagen_result_final$yield_ratio)^2

metagen_result_final$pred_fixed <- predict(nlme_fit, level = 0)

resid_fixed <- metagen_result_final$yield_ratio - metagen_result_final$pred_fixed

ss_res_fixed <- sum(resid_fixed^2)
ss_total <- sum((metagen_result_final$yield_ratio - mean(metagen_result_final$yield_ratio))^2)
r2_marginal <- 1 - ss_res_fixed / ss_total

# Predict using only fixed effects
new_data_nlme$predicted <- predict(nlme_fit, newdata = new_data_nlme, level = 0)

em_nlme <- emmeans(nlme_fit, ~ plant_prcp, at = list(plant_prcp = 10), 
                        param = names(fixef(nlme_fit)),)

summary(em_nlme, infer = c(TRUE, TRUE), level = 0.95)
# Calculate RMSE and pseudo-R²
residuals <- residuals(nlme_fit)
rmse <- sqrt(mean(residuals^2))
ss_total <- sum((metagen_result_final$yield_ratio - mean(metagen_result_final$yield_ratio))^2)
ss_residual <- sum(residuals^2)
pseudo_r2 <- 1 - (ss_residual / ss_total)
###

nlme_ci <- intervals(nlme_fit, which = "fixed")$fixed
pred_se <- sqrt(t(c(1, 10)) %*% vcov(nlme_fit) %*% c(1, 10))

yield_ratio <- seq(0.6,1,0.1)
precip_by_ratio <- rep(NA, length(yield_ratio))

for(i in 1:length(yield_ratio)){
  precip_by_ratio[i] <- (log(yield_ratio[i])+0.5508)/0.033
}
precip_by_ratio_df <- data.frame(yield_ratio, precip_by_ratio)



### Looking at NLME and confidence intervals
x_vals <- seq(min(metagen_result_final$plant_prcp),
              max(metagen_result_final$plant_prcp),
              length.out = 100)

newdata <- data.frame(plant_prcp = x_vals)

# Bootstrap predictions
set.seed(123)
boot_preds <- replicate(300, {
  boot_data <- metagen_result_final[sample(nrow(metagen_result_final), replace = TRUE), ]
  fit_try <- try(update(nlme_fit, data = boot_data), silent = TRUE)
  if (inherits(fit_try, "try-error")) return(rep(NA, length(x_vals)))
  predict(fit_try, newdata = newdata, level = 0)
})

# Clean up failed bootstraps
boot_preds <- boot_preds[, colSums(is.na(boot_preds)) == 0]

# Calculate 95% CI bands
ci_lower <- apply(boot_preds, 1, quantile, probs = 0.025)
ci_upper <- apply(boot_preds, 1, quantile, probs = 0.975)
ci_mean  <- apply(boot_preds, 1, mean)

plot(yield_ratio ~ plant_prcp, data = metagen_result_final, pch = 16, col = 'gray')
lines(x_vals, ci_mean, col = "blue", lwd = 2)
lines(x_vals, ci_lower, col = "blue", lty = 2)
lines(x_vals, ci_upper, col = "blue", lty = 2)


target_y <- 0.89

x_lo <- approx(x = ci_lower, y = x_vals, xout = target_y)$y
x_hi <- approx(x = ci_upper, y = x_vals, xout = target_y)$y

cat("Approximate x-range where CI includes y =", target_y, ":\n")
cat("From x ≈", round(x_lo, 2), "to x ≈", round(x_hi, 2), "\n")
```

```{r APSIM Yield Data}
apsim_raw <- readxl::read_xlsx("~/Downloads/Soybean_Yga_project.xlsx")

apsim_update <- apsim_raw %>%
  mutate(year = year(Clock.Today)) %>%
  group_by(SimulationName, year) %>%
  summarise(final_soy = max(soy_kg_ha, na.rm = T)) %>%
  ungroup() %>%
  mutate(tillage = case_when(
    SimulationName == "Daymet Tillage" ~ "Till",
    .default = "No Till"
  )) %>%
  filter(final_soy > 0)

apsim_nt <- apsim_update %>%
  filter(tillage == "No Till",
         year %in% proj_yields$Year) 


proj_yields <- combined_filtered_results %>%
  filter(State == "NY") %>%
  distinct(Year, Till_NT, Yield_Mgha) %>%
  group_by(Year, Till_NT) %>%
  summarise(mean_yld = 1000*mean(Yield_Mgha))

proj_nt <- proj_yields %>%
  filter(Till_NT == "NT")

apsim_update %>%
  filter(year > 2013) %>%
  ggplot(aes(x = year, y = final_soy, colour = tillage)) +
  geom_point() +
  geom_line() +
  theme_bw() + 
  geom_point(data = proj_yields, aes(x = Year, y = mean_yld, color = Till_NT)) + 
  geom_line(data = proj_yields, aes(x = Year, y = mean_yld, color = Till_NT)) + 
  labs(x = "Year", y = "Soybean yield (Kg/ha)", color = "Tillage")



apsim_rye <- read_csv("~/Downloads/Soybean_Yga_project.Report.csv")

apsim_rye_upd <- apsim_rye %>%
  mutate(Year = year(as.Date(Clock.Today, format = "%m/%d/%y")))  %>%
  group_by(Year) %>%
  summarise(final_rye = max(rye_bm_kg_ha, na.rm = T)) %>%
  ungroup() 

apsim_rye_upd %>%
  ggplot(aes(x = Year, y = final_rye)) +
  geom_line(linewidth = 2) +
  geom_point(size = 3) +
  theme_bw() +
  labs(x = "Year", y = "Cereal rye biomass (kg/ha)")




rye_obs <- comb_soy_prcp %>%
  filter(State == "NY") %>%
  group_by(Year) %>%
  summarise(final_rye = mean(RyeBiomass_kgha, na.rm = T)) %>%
  mutate(type = rep("obs")) %>%
  filter(Year != 2017)


apsim_preds <- apsim_rye_upd %>%
  mutate(type = rep("preds")) %>%
  filter(Year %in% rye_obs$Year)

pred_obs <- rbind(apsim_preds, rye_obs)


pred_obs %>%
  ggplot(aes(x = factor(Year), y = final_rye, color = type)) +
  geom_line(aes(group = type)) + 
  geom_point() +
  theme_pubclean() +
  labs(x = "Year", y = "Cereal rye biomass (Kg/ha)", color = "")

pred_obs_wide <- pred_obs %>%
  pivot_wider(values_from = final_rye,names_from = type) 

rye_pred_obs_plot <- pred_obs_wide %>%
  ggplot(aes(x = obs, y = preds)) +
  geom_abline(slope = 1) +
  geom_point() +
  theme_pubr() +
  geom_text(aes(x = 3550, y = 9400, label =paste0("R-RMSE: ",r_rmse," %")), size = 5) +
  labs(x = "Observed cereal rye biomass (kg/ha)", y = "Predicted cereal rye biomass (kg/ha)") +
  stat_poly_eq(size = 5) +
  coord_cartesian(ylim = c(3000, 10000), xlim = c(3000,10000)) +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14),
        strip.text = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14))
ggsave(rye_pred_obs_plot, filename = "Figures/cr_pred_obs.png",
       dpi = 300, width = 9, height = 6, units = "in")


mean(soy_rye_raw$RyeSeedingRate_lbac[soy_rye_raw$State == "NY"], na.rm = T)

rmse_rye <- rmse(pred_obs_wide$preds,pred_obs_wide$obs)
mean_rye_obs <- mean(pred_obs_wide$obs)
r_rmse <- round((rmse_rye/mean_rye_obs)*100,2)


nse_top <- sum((pred_obs_wide$preds-pred_obs_wide$obs)^2)
nse_bot <- sum((pred_obs_wide$obs-mean(pred_obs_wide$obs))^2)
nse <- 1-(nse_top/nse_bot)

weed_obs <- comb_soy_prcp %>%
  filter(Location == "Musgrave",
         Till_NT == "NT") %>%
  group_by(Year) %>%
  summarise(weed_bm = mean(as.numeric(WeedBiomass_kgha), na.rm = T),
            mean_rye = mean(RyeBiomass_kgha, na.rm = T)) %>%
  mutate(type = rep("obs"))

weed_obs %>%
  ggplot(aes(x = weed_bm, y = mean_rye)) +
  geom_smooth(se = F, method = "lm") +
  geom_point() +
  stat_poly_eq() +
  theme_pubclean()


mus_rye_apsim_match <- read_csv("~/Downloads/rye_model_experiments.Report.csv")

mus_apsim_rye_upd <- mus_rye_apsim_match %>%
  mutate(Year = year(as.Date(Clock.Today, format = "%m/%d/%y")))  %>%
  group_by(Year) %>%
  summarise(final_rye_pred = max(rye_bm_kg_ha, na.rm = T)) %>%
  ungroup() %>%
  filter(Year %in% rye_obs$Year) 

real_obs_pred <- left_join(mus_apsim_rye_upd, rye_obs)


rye_pred_obs_real <- real_obs_pred %>%
  ggplot(aes(x = final_rye, y = final_rye_pred)) +
  geom_abline(slope = 1) +
  geom_point() +
  theme_pubr() +
  #geom_text(aes(x = 3550, y = 9400, label =paste0("R-RMSE: ",r_rmse," %")), size = 5) +
  labs(x = "Observed cereal rye biomass (kg/ha)", y = "Predicted cereal rye biomass (kg/ha)") +
  stat_poly_eq(size = 5) +
  coord_cartesian(ylim = c(3000, 11000), xlim = c(3000,11000)) +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 14),
        strip.text = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 14))


rmse_rye <- rmse(real_obs_pred$final_rye_pred,real_obs_pred$final_rye)
mean_rye_obs <- mean(real_obs_pred$final_rye)
r_rmse <- round((rmse_rye/mean_rye_obs)*100,2)


nse_top <- sum((real_obs_pred$final_rye_pred-real_obs_pred$final_rye)^2)
nse_bot <- sum((real_obs_pred$final_rye-mean(real_obs_pred$final_rye))^2)
nse <- 1-(nse_top/nse_bot)

```

```{r Comaring NEWA to PRISM}

mus_newa_23 <- clean_names(read_csv("~/Downloads/mus_2023_newa.csv"))

mus_newa_metric <- mus_newa_23 %>%
  mutate(date_newa = as.Date(date, format = "%m/%d/%y"),
         prcp_newa = total_precipitation*2.54,
         mint_c_newa = (min_air_temp_f-32)*(5/9),
         maxt_c_newa = (max_air_temp_f-32)*(5/9)) %>%
  dplyr::select(date_newa, prcp_newa, mint_c_newa, maxt_c_newa) %>%
  mutate(dataset_newa = rep("NEWA"))

prism_2023 <- musgrave_prism %>%
  filter(Year == 2023) %>% 
  mutate(dataset = rep("PRISM")) %>%
  dplyr::select(date, prcp_cm, mint_c, maxt_c, dataset)


compare_met <- cbind(mus_newa_metric, prism_2023)

compare_met <- compare_met %>%
  mutate(cum_newa_prcp = cumsum(prcp_newa),
         cum_prism_prcp = cumsum(prcp_cm))


compare_met %>%
  ggplot(aes(x = cum_newa_prcp, y = cum_prism_prcp)) +
  geom_point() +
  geom_abline(slope = 1) +
  stat_poly_eq(formula = y~x, use_label(c("R2", "eq")), size = 5) +
  theme_pubr()

cor(compare_met$cum_newa_prcp, compare_met$cum_prism_prcp)^2


nse_top <- sum((compare_met$cum_prism_prcp-compare_met$cum_newa_prcp)^2)
nse_bot <- sum((compare_met$cum_newa_prcp-mean(compare_met$cum_newa_prcp))^2)
nse <- 1-(nse_top/nse_bot)
```

```{r Solar radiation Data}
library(daymetr)
library(nasapower)

# Example: Daily data for 2022
mus_srad <- download_daymet(
  lat = 42.734, 
  lon = -76.657,
  start = 1982,
  end = 2024,
  internal = TRUE
)

mus_srad_df <- clean_names(mus_srad$data) %>%
  mutate(Location = rep("Musgrave"))

soy_daymet <- soy_rye_useful %>%
  mutate(year = Year)

daymet_prcp <- function(met_df, mgmt_df, station_site){

  # met_df: Dataframe that includes precipitation data, year, and date at least to calculate precipitation around planting.
  # mgmt_df: Dataframe that includes soybean management and agronomic information, including planting date
  # station_site: String input for the name of experimental site (Musgrave, Arlington, Geneva, PSU, etc.)

# Find planting dates for the location for each experiment and year
  planting_dates <- mgmt_df %>%
    group_by(year, Location) %>%
    slice_min(SoySeedingDate)%>%
    ungroup() %>%
    filter(Location == station_site) %>%
    dplyr::select(ExperimentName, year, State, Location, SoySeedingDate) %>%
    distinct()
  
  exp_df <- left_join(met_df, planting_dates, by = c("year","Location")) %>%
    mutate(plant_doy = yday(SoySeedingDate))
#### Calculates the precipitation +/- 15 days around planting period for each planting date at the site 
  plant_prcp <- exp_df %>%
    filter(!is.na(SoySeedingDate) & yday >= plant_doy - 15 & yday<= plant_doy + 15) %>%
    group_by(ExperimentName, year, State, Location, SoySeedingDate) %>%
    summarise(plant_prcp = sum(prcp_mm_day, na.rm = T)/10, .groups = "drop")
  return(plant_prcp)
}
daymet_plant_prcp <- daymet_prcp(met_df = mus_srad_df, mgmt_df = soy_daymet, station_site = "Musgrave")

prism_comparison <- musgrave_plant_prcp %>%
  filter(Year < 2024)

climod_comp <- c(6.95,2.89,6.39,2.23,1.35,4.46)*2.54

cor(daymet_plant_prcp$plant_prcp, prism_comparison$plant_prcp)^2
cor(daymet_plant_prcp$plant_prcp, climod_comp)^2
cor(prism_comparison$plant_prcp, climod_comp)^2

#### Checking some climod data to see if it is better

climod_data <- read_csv("~/Downloads/musgrave_climod_check.csv")
filter_chars <- c("T", "M", "S", "A")

climod_data$Precipitation <- gsub("A","",musgrave_weather$Precipitation)

climod_missing <- climod_data %>%
  filter(Precipitation == "M")

climod_clean <- climod_data %>% 
  mutate(Precipitation = na_if(Precipitation, "T")) %>%
  mutate(Precipitation = na_if(Precipitation, "S")) %>%
  mutate(Precipitation = na_if(Precipitation, "M")) %>%
  mutate(Precipitation = as.numeric(Precipitation)) %>%
  mutate(Precipitation = replace_na(Precipitation,0)) %>%
  mutate(Date = as.Date(Date, format = "%m/%d/%y")) %>%
  mutate(day_of_year = yday(Date)) %>%
  mutate(Year = year(Date)) %>%
  mutate(month = month(Date)) 

climod_metric <- climod_clean %>%
  mutate(date = Date,
         year = Year,
         yday = day_of_year,
         prcp_cm = Precipitation*2.54) %>%
  dplyr::select(date, year, yday,, prcp_cm) %>%
  mutate(Location = rep("Musgrave"))

climod_prcp <- function(met_df, mgmt_df, station_site){

  # met_df: Dataframe that includes precipitation data, year, and date at least to calculate precipitation around planting.
  # mgmt_df: Dataframe that includes soybean management and agronomic information, including planting date
  # station_site: String input for the name of experimental site (Musgrave, Arlington, Geneva, PSU, etc.)

# Find planting dates for the location for each experiment and year
  planting_dates <- mgmt_df %>%
    group_by(year, Location) %>%
    slice_min(SoySeedingDate)%>%
    ungroup() %>%
    filter(Location == station_site) %>%
    dplyr::select(ExperimentName, year, State, Location, SoySeedingDate) %>%
    distinct()
  
  exp_df <- left_join(met_df, planting_dates, by = c("year","Location")) %>%
    mutate(plant_doy = yday(SoySeedingDate))
#### Calculates the precipitation +/- 15 days around planting period for each planting date at the site 
  plant_prcp <- exp_df %>%
    filter(!is.na(SoySeedingDate) & yday >= plant_doy - 15 & yday<= plant_doy + 15) %>%
    group_by(ExperimentName, year, State, Location, SoySeedingDate) %>%
    summarise(plant_prcp = sum(prcp_cm, na.rm = T), .groups = "drop")
  return(plant_prcp)
}

climod_plant_prcp <- climod_prcp(climod_metric, soy_daymet, "Musgrave") 
climod_no2016 <- climod_plant_prcp %>%
  filter(year != 2016,
         year != 2024)
mus_pcp_no2016 <- musgrave_plant_prcp %>%
  filter(Year != 2016) 

cor(climod_no2016$plant_prcp , mus_pcp_no2016$plant_prcp)^2

sqrt(1/nrow(climod_no2016)*sum((mus_pcp_no2016$plant_prcp-climod_no2016$plant_prcp)^2))
mean(climod_no2016$plant_prcp)


#### Looking at soil water balance to find deficit at planting

lat_mus <- 42.734
lon_mus <- -76.657    
start_date <- "1981-01-01"
end_date <- "2024-12-31"

# Get daily data for a single point
power_data <- get_power(
  community = "AG",         # Agricultural data
  lonlat = c(lon_mus, lat_mus),
  pars = c("ALLSKY_SFC_SW_DWN"),  
  dates = c(start_date, end_date)
)
power_clean <- power_data %>%
  drop_na() %>%
  mutate(date = YYYYMMDD,
         rad_n = ALLSKY_SFC_SW_DWN) %>%
  dplyr::select(date, rad_n)


calc_pt_et <- function(tmin, tmax, rs, albedo = 0.23, alpha = 1.26, lambda = 2.45, gamma = 0.0665) {
  
  # Mean temperature
  tmean <- (tmin + tmax) / 2
  
  # Saturation vapor pressure (kPa)
  es <- 0.6108 * exp((17.27 * tmean) / (tmean + 237.3))
  
  # Slope of saturation vapor pressure curve (Δ, in kPa/°C)
  delta <- (4098 * es) / ((tmean + 237.3)^2)
  
  # Net radiation (Rn) approximation (MJ/m²/day)
  rn <- (1 - albedo) * rs
  
  # Priestley-Taylor ET₀ (mm/day)
  eto <- alpha * (delta / (delta + gamma)) * rn / lambda
  
  return(eto)
}

prism_power <- left_join(musgrave_prism,power_clean) %>%
  drop_na() %>%
  mutate(aw_cm = rep(NA),
         excess_cm = rep(NA),
         pet_cm = calc_pt_et(tmin = mint_c, tmax = maxt_c, rs = rad_n)/10)

awc <- 0.15
depth <- 30
wp <- 0.12
wp_cm <- wp*depth

awc_cm <- awc*depth
prism_power$aw_cm[1] <- awc_cm


for(i in 2:nrow(prism_power)){
  pet <- prism_power$pet_cm[i]
  precip <- prism_power$prcp_cm[i]
  pet_n_cm <- pet - precip
  aw_prev <- prism_power$aw_cm[i-1]
  
  if(pet_n_cm == 0){
    aw <- aw_prev
  } else if (pet_n_cm > 0){
    aw <- aw_prev*exp(-pet/awc_cm)
  } else if (pet_n_cm < 0 && (aw_prev-pet_n_cm) <= awc_cm){
    aw <- aw_prev-pet_n_cm
  } else{
    aw <- awc_cm
  }
  prism_power$aw_cm[i] <- aw
}

prism_power_all <- prism_power %>%
  mutate(pet_n_cm = pet_cm - prcp_cm,
         excess_cm = case_when(pet_n_cm < 0 & dplyr::lag(aw_cm)-pet_n_cm > awc_cm ~ lag(aw_cm)-pet_n_cm-awc_cm,
                               .default = 0),
         et = pet_cm*(aw_cm/awc_cm),
         swd_cm = aw_cm-(0.12*depth)
  )

prism_power_all <- prism_power %>%
  mutate(
    doy = yday(date),
    kc = case_when(
      doy <= 90 ~ 0.4,
      doy <= 120 ~ 0.4 + (doy - 90) * (0.4 / 30) ,   # Apr 1–Apr 30: linear 0.4 to 0.8
      doy <= 150 ~ 0.8 + (doy - 120) * (0.2 / 30),  # May 1–May 30: 0.8 to 1.0
      doy <= 160 ~ 1.0 - (doy - 150) * (0.6 / 10),  # June 1–June 10: senescence
      TRUE ~ 0.4  # after termination or mowing
    ),
    aet_cm = pet_cm * kc  # or et0_cm if using that
  )


 ### gpt
for(i in 2:nrow(prism_power_all)){
  pet <- prism_power_all$pet_cm[i]
  precip <- prism_power_all$prcp_cm[i]
  net_pet <- pet - precip
  aw_prev <- prism_power_all$aw_cm[i - 1]
  
  if (net_pet > 0) {
    aw <- max(aw_prev - net_pet, 0)
  } else {
    aw <- min(aw_prev - net_pet, awc_cm)
  }
  
  prism_power_all$aw_cm[i] <- aw
}

prism_power_all <- prism_power_all %>%
  mutate(
    net_pet_cm = pet_cm - prcp_cm,
    et_cm = pet_cm * (aw_cm / awc_cm),
    swd_cm = pmin(aw_cm - (0.12*depth),0),
    excess_cm = pmax(0, aw_cm + prcp_cm - pet_cm - awc_cm)
  )



### GPT approach for each year as independent
planting_dates_df <- musgrave_plant_prcp %>%
  dplyr::select(ExperimentName, SoySeedingDate, Year)

prism_power_all <- prism_power_all %>%
  mutate(
    Year = year(date),
    doy = yday(date)
  ) %>%
  filter(Year %in% planting_dates_df$Year) %>%
  left_join(
    planting_dates_df %>%
      mutate(planting_doy = yday(SoySeedingDate)),
    by = "Year"
  )

soil_balance_by_year <- list()

# Set constants
depth <- 30        # cm
awc <- 0.15        # cm/cm
awc_cm <- awc * depth
wp <- 0.12         # wilting point (cm/cm)
wp_cm <- wp * depth

# Initialize result list
soil_balance_by_year <- list()

# Loop over years
for(yr in unique(prism_power_all$Year)) {
  yearly_data <- prism_power_all %>%
    filter(Year == yr, doy <= planting_doy+15) %>%
    arrange(date)
  
  n_days <- nrow(yearly_data)
  aw_vector <- numeric(n_days)
  aw_vector[1] <- awc_cm  

  for(i in 2:n_days){
    stress <- max((aw_vector[i - 1] / awc_cm), 0.1)^0.5
    
    aet <- yearly_data$aet_cm[i]*stress
    precip <- yearly_data$prcp_cm[i]
    net <- aet - precip
    aw_prev <- aw_vector[i-1]
    
    aw <- max(min(aw_prev - net, awc_cm), 0)  # constrain to [WP, AWC]
    aw_vector[i] <- aw
  }
  
  # Add results to the data frame
  yearly_data$aw_cm <- aw_vector
  yearly_data$swd_cm <- aw_vector - wp_cm  
  
  soil_balance_by_year[[as.character(yr)]] <- yearly_data
}

# Combine all years
final_soil_balance <- bind_rows(soil_balance_by_year)

final_soil_balance %>%
  mutate(exp_year = paste0(ExperimentName,"-",Year)) %>%
  ggplot(aes(x = date, y = swd_cm)) +
  facet_wrap(~exp_year, scales = "free_x") +
  geom_point() +
  geom_line() +
  geom_vline(aes(xintercept = SoySeedingDate), color = "red") +
  theme_pubr()


swd_at_plant <- final_soil_balance %>%
  group_by(Year) %>%
  summarise(swd_plant = mean(swd_cm[doy >= planting_doy-15 & doy <= planting_doy+15])) %>%
  mutate(State = rep("NY"))

mus_ratios$Year <- year(mus_ratios$SoySeedingDate)

swd_mus <- left_join(mus_ratios, swd_at_plant) %>%
  filter(Year < 2024)

cor(swd_mus$yield_ratio, swd_mus$plant_prcp)^2

swd_mus %>%
  ggplot(aes(x = swd_plant, y = yield_ratio)) +
  geom_point() +
  theme_pubr() +
  stat_poly_eq()

### Everything for Wisconsin 

lat_arl <- 43.30294
lon_arl <- -89.34670   
start_date <- "1981-01-01"
end_date <- "2024-12-31"

# Get daily data for a single point
power_data_wi <- get_power(
  community = "AG",         
  lonlat = c(lon_arl, lat_arl),
  pars = c("ALLSKY_SFC_SW_DWN"),  
  dates = c(start_date, end_date)
)

power_clean_wi <- power_data_wi %>%
  drop_na() %>%
  mutate(date = YYYYMMDD,
         rad_n = ALLSKY_SFC_SW_DWN) %>%
  dplyr::select(date, rad_n)

prism_power_wi <- left_join(arlington_prism,power_clean_wi) %>%
  drop_na() %>%
  mutate(aw_cm = rep(NA),
         excess_cm = rep(NA),
         pet_cm = calc_pt_et(tmin = mint_c, tmax = maxt_c, rs = rad_n)/10)

planting_dates_df_wi <- wi_plant_prcp %>%
  dplyr::select(ExperimentName, SoySeedingDate, Year)

prism_power_all_wi <- prism_power_wi %>%
  mutate(
    doy = yday(date),
    kc = case_when(
      doy <= 90 ~ 0.4,
      doy <= 120 ~ 0.4 + (doy - 90) * (0.4 / 30) ,   # Apr 1–Apr 30: linear 0.4 to 0.8
      doy <= 150 ~ 0.8 + (doy - 120) * (0.2 / 30),  # May 1–May 30: 0.8 to 1.0
      doy <= 160 ~ 1.0 - (doy - 150) * (0.6 / 10),  # June 1–June 10: senescence
      TRUE ~ 0.4  # after termination or mowing
    ),
    aet_cm = pet_cm * kc  # or et0_cm if using that
  )

prism_power_all_wi <- prism_power_all_wi %>%
  mutate(
    Year = year(date),
    doy = yday(date)
  ) %>%
  filter(Year %in% planting_dates_df_wi$Year) %>%
  left_join(
    planting_dates_df_wi %>%
      mutate(planting_doy = yday(SoySeedingDate)),
    by = "Year"
  )

soil_balance_by_year <- list()

# Set constants
depth <- 30        # cm
awc_wi <- 0.23       # cm/cm
awc_cm_wi <- awc_wi * depth
wp_wi <- 0.153         # wilting point (cm/cm)
wp_cm_wi <- wp_wi * depth

# Initialize result list
soil_balance_by_year_wi <- list()

# Loop over years
for(yr in unique(prism_power_all_wi$Year)) {
  yearly_data <- prism_power_all_wi %>%
    filter(Year == yr, doy <= planting_doy+15) %>%
    arrange(date)
  
  n_days <- nrow(yearly_data)
  aw_vector <- numeric(n_days)
  aw_vector[1] <- awc_cm_wi  

  for(i in 2:n_days){
    stress <- max((aw_vector[i - 1] / awc_cm_wi), 0.1)^0.5
    
    aet <- yearly_data$aet_cm[i]*stress
    precip <- yearly_data$prcp_cm[i]
    net <- aet - precip
    aw_prev <- aw_vector[i-1]
    
    aw <- max(min(aw_prev - net, awc_cm_wi), 0)  # constrain to [WP, AWC]
    aw_vector[i] <- aw
  }
  
  # Add results to the data frame
  yearly_data$aw_cm <- aw_vector
  yearly_data$swd_cm <- aw_vector - wp_cm_wi  
  
  soil_balance_by_year_wi[[as.character(yr)]] <- yearly_data
}

# Combine all years
final_soil_balance_wi <- bind_rows(soil_balance_by_year_wi)

final_soil_balance_wi %>%
  mutate(exp_year = paste0(ExperimentName,"-",Year)) %>%
  ggplot(aes(x = date, y = swd_cm)) +
  facet_wrap(~exp_year, scales = "free_x") +
  geom_point() +
  geom_line() +
  geom_vline(aes(xintercept = SoySeedingDate), color = "red") +
  theme_pubr()


swd_at_plant_wi <- final_soil_balance_wi %>%
  group_by(Year) %>%
  summarise(swd_plant = mean(swd_cm[doy >= planting_doy-15 & doy <= planting_doy+15])) %>%
  mutate(State = rep("WI"))


swd_ny_wi <- rbind(swd_at_plant, swd_at_plant_wi) 

all_ratios <- metagen_result_final_1 %>%
  dplyr::select(State, Year, ExperimentName, yield_ratio)


swd_ratio_all <- left_join(swd_ny_wi, all_ratios)

swd_ratio_all %>%
  filter(ExperimentName != "Mowtivation") %>%
  ggplot(aes(x = swd_plant, y = yield_ratio)) +
  geom_point(aes(color = State)) +
  geom_text(aes(label = paste0(ExperimentName," ", Year))) +
  stat_poly_eq() +
  theme_pubr()
#### Although this looks cool, I think there are too many assumptions being made, especially in the period post soybean planting. Therefore it may be more straightforward to stick with precipitation and let the soil water balance stuff rest for now. 

```

```{r Soybean ANCOVA}
ancova_data <- combined_filtered_results %>%
  mutate(Till_NT = as.factor(Till_NT),
         pdoy = yday(SoySeedingDate.x)) %>%
  filter(Year < 2024)

ancova_data$plant_prcp[ancova_data$ExperimentName == "Starter Fertilizer Study"] <- 7.44

ancova_mod2 <-  lmer(Yield_Mgha ~ Till_NT*plant_prcp + (1|State:ExperimentName:Year:block) + (1|State:ExperimentName:Year) +
                     (1|ExperimentName),
                   data = ancova_data)

car::Anova(ancova_mod2, type =3)


summary(ancova_mod2)
check_model(ancova_mod2)
performance::r2(ancova_mod2)
hist(resid(ancova_mod2))
qqnorm(resid(ancova_mod2))
qqline(resid(ancova_mod2))

plot(ancova_mod2)

ancova_slopes <- emtrends(ancova_mod2,pairwise ~ Till_NT, var = "plant_prcp")
summary(ancova_slopes, infer = c(T, T))


emmeans(ancova_mod2, ~ Till_NT, at = list(plant_prcp = 0))



emmip(ancova_mod2, Till_NT ~ plant_prcp, cov.reduce = range)


library(ggeffects)

gg_preds <- ggpredict(ancova_mod2, terms = c("plant_prcp","Till_NT"))

summary(ancova_mod2)
fixed_effects <- fixef(ancova_mod)

#till_eq <- paste0("y = ", round(fixed_effects[1],3), " + ", round(fixed_effects[3],3), "x")
#nt_eq <- paste0("y = ",round(fixed_effects[1]+fixed_effects[2],3), " + ", round(fixed_effects[3]+fixed_effects[4],3),"x")

ancova_plot <- ancova_data %>% 
  group_by(ExperimentName,Year, Till_NT) %>%
  mutate(mean_yield = mean(Yield_Mgha)) %>%
  ggplot() +
  geom_point(aes(x = plant_prcp, y = mean_yield, colour = Till_NT, shape = State), size =3) +
  geom_line(data = gg_preds, aes(x = x, y = predicted, colour = group)) +
  geom_ribbon(data = gg_preds, aes(x = x,ymin = conf.low, ymax = conf.high,fill  = group),alpha = 0.2) +
  scale_color_manual(values = c("black", "red"))+
  scale_shape_manual(values = c("triangle","square")) +
  scale_fill_manual(values = c("black","red")) +
  #annotate("text", x = 12, y = 5, label = nt_eq, color = "black", size = 5) +
  #annotate("text", x = 12, y = 4.8, label = till_eq, color = "red", size = 5) +
  theme_pubr() + 
  labs(y = "Soybean yield (Mg/ha)", x = "Precipitation recieved +/- 15 days of planting (cm)", fill = "", shape = "", color = "") +
  guides(fill = "none") +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        legend.text = element_text(size = 12))


stand_model


doy_mod <-  lmer(Yield_Mgha ~ (Till_NT) * pdoy + (1|State:ExperimentName:Year:block) + (1|State:ExperimentName:Year) +
                     (1|ExperimentName),
                   data = ancova_data %>% filter(Year < 2024))

summary(doy_mod)
check_model(doy_mod)
performance::r2(doy_mod)
hist(resid(doy_mod))
qqnorm(resid(doy_mod))
qqline(resid(doy_mod))

doy_trends <- emtrends(doy_mod,pairwise ~ Till_NT, var = "pdoy")
summary(doy_trends, infer = c(T,T))

emmeans(doy_mod, ~ Till_NT, at = list(pdoy = 0))

gg_preds_doy <- ggpredict(doy_mod, terms = c("pdoy","Till_NT"))

ancova_data %>% 
  group_by(ExperimentName,Year, Till_NT) %>%
  mutate(mean_yield = mean(Yield_Mgha)) %>% 
  filter(Year < 2024) %>%
  ggplot() +
  geom_point(aes(x = pdoy, y = mean_yield, colour = Till_NT, shape = State), size =3) +
  geom_line(data = gg_preds_doy, aes(x = x, y = predicted, colour = group)) +
  geom_ribbon(data = gg_preds_doy, aes(x = x,ymin = conf.low, ymax = conf.high,fill  = group),alpha = 0.2) +
  scale_color_manual(values = c("black", "red"))+
  scale_shape_manual(values = c("triangle","square")) +
  scale_fill_manual(values = c("black","red")) +
  theme_pubr() + 
  labs(y = "Soybean yield (Mg/ha)", x = "Planting day of year", fill = "", shape = "", color = "") +
  guides(fill = "none") +
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        legend.text = element_text(size = 12))


#### Looking at return times of precipitation for all planting periods

get_window_sums_multiple_doys <- function(weather_data, doy_targets, window_size = 15) {
  
  
  all_years <- unique(weather_data$Year)
  
  result_list <- map(doy_targets, function(doy_target) {
    sums <- map_dbl(all_years, function(yr) {
      this_year <- weather_data %>% filter(Year == yr)
      window_days <- ((doy_target - window_size):(doy_target + window_size)) %% 366
      window_days[window_days == 0] <- 366  # Wrap-around fix
      this_year %>%
        filter(doy %in% window_days) %>%
        summarise(sum_precip = sum(prcp_cm, na.rm = TRUE)) %>%
        pull(sum_precip)
    })
    tibble(DOY = doy_target, Year = all_years, SumPrecip = sums)
  })
  
  bind_rows(result_list)
}

musgrave_doys <- unique(yday(combined_filtered_results$SoySeedingDate.x[combined_filtered_results$Location == "Musgrave"]))

precip_sums_mus <- get_window_sums_multiple_doys(musgrave_prism, seq(150,170,1))

target_value_ny <- 10 #### From the meta analysis, this is the precipitation to get 90% of the till yield in NT

return_periods_df <- precip_sums_mus %>%
  group_by(DOY) %>%
  arrange(desc(SumPrecip)) %>%
  mutate(
    Rank = row_number(),
    n = n(),
    ReturnPeriod = (n + 1) / Rank
  ) %>%
  summarise(
    TargetReturnPeriod = approx(x = log(SumPrecip), y = ReturnPeriod, xout = log(target_value_ny))$y,
    .groups = "drop"
  )

return_periods_df %>%
  ggplot(aes(x = DOY, y = TargetReturnPeriod)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x) +
  theme_pubr() +
  stat_poly_eq(formula = y~x) +
  labs(y = "Return period for target precipitation (years)", x = "Day of year", title = "Musgrave")

compute_return_period_df <- function(df) {
  sums <- df$SumPrecip
  sorted <- sort(sums, decreasing = TRUE)
  ranks <- rank(-sorted, ties.method = "first")
  n <- length(sorted)
  tibble(
    Precip = sorted,
    ReturnPeriod = (n + 1) / ranks
  )
}

return_curves_df <- precip_sums_mus %>%
  group_by(DOY) %>%
  summarise(ReturnData = list(compute_return_period_df(cur_data())),
            .groups = "drop") %>%
  unnest(ReturnData)

return_curves_df %>%
  ggplot(aes(x = ReturnPeriod, y = Precip)) +
  geom_point() +
  geom_line() +
  facet_wrap(~DOY,scales = "free") +
  theme_pubr() +
  geom_hline(yintercept = 13.53, color = "red")

### Same stuff for Wisconsin

wi_doys <- unique(yday(combined_filtered_results$SoySeedingDate.x[combined_filtered_results$Location == "AARS"]))

precip_sums_arl <- get_window_sums_multiple_doys(arlington_prism, seq(150,170,2))

return_curves_wi <- precip_sums_arl %>% 
  filter(SumPrecip > 0) %>%
  group_by(DOY) %>%
  summarise(
    Fit = list(fitdist(SumPrecip, "lnorm")),
    Sums = list(SumPrecip),
    .groups = "drop"
  ) %>%
  mutate(
    ReturnData = map(Sums, function(x) {
      sorted <- sort(x, decreasing = TRUE)
      ranks <- rank(-sorted, ties.method = "first")
      n <- length(sorted)
      return_periods <- (n + 1) / ranks
      tibble(Precip = sorted, ReturnPeriod = return_periods)
    })
  )

target_value_wi <- 10
return_periods_df_wi <- precip_sums_arl %>%
  group_by(DOY) %>%
  arrange(desc(SumPrecip)) %>%
  mutate(
    Rank = row_number(),
    n = n(),
    ReturnPeriod = (n + 1) / Rank
  ) %>%
  summarise(
    TargetReturnPeriod = approx(x = log(SumPrecip), y = ReturnPeriod, xout = log(target_value_wi))$y,
    .groups = "drop"
  )

return_periods_df_wi %>%
  ggplot(aes(x = DOY, y = TargetReturnPeriod)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x) +
  theme_pubr() +
  stat_poly_eq(formula = y~x) +
  labs(y = "Return period for target precipitation (years)", x = "Day of year", title = "Arlington") #### Wisconsin plot is really linear!!!


return_curves_df_wi <- precip_sums_arl %>%
  group_by(DOY) %>%
  summarise(ReturnData = list(compute_return_period_df(cur_data())),
            .groups = "drop") %>%
  unnest(ReturnData)

return_curves_df_wi %>%
  ggplot(aes(x = ReturnPeriod, y = Precip)) +
  geom_point() +
  geom_line() +
  facet_wrap(~DOY,scales = "free") +
  theme_pubr() +
  geom_hline(yintercept = 13.53, color = "red") #### This plot hints that Wisconsin frequently gets more sufficient rain for this system to work at getting 90% of Till yield in NT
```

```{r Conditional Inference Tree}
library(partykit)
library(ggparty)

soybean_precip <- soy_rye_std %>%
  left_join(all_plant_prcp, by = c("Year", "State")) %>%
  mutate(pdoy = yday(as.Date(SoySeedingDate.x, format = "%m/%d/%y")),
         WeedBiomass_kgha = as.numeric(WeedBiomass_kgha),
         Till_NT = as.factor(Till_NT),
         State = as.factor(State),
         exp_treat = as.factor(ExperimentalTrt)) %>% 
  filter(Year < 2024) %>%
  dplyr::select(Year,State, Till_NT, Yield_Mgha, plant_prcp, WeedBiomass_kgha, pdoy) %>%
  mutate(year_fac = as.factor(Year)) %>%
  drop_na()

control = ctree_control(mincriterion = 1-(.05*ncol(soybean_precip)-1))

cit_soy <- ctree(Yield_Mgha ~ as.factor(State) + Till_NT + plant_prcp, data = ancova_data)

pred_soy <- predict(cit_soy)
obs_soy <- ancova_data$Yield_Mgha

rmse <- sqrt(mean((obs_soy - pred_soy)^2))

ss_res <- sum((obs_soy - pred_soy)^2)
ss_tot <- sum((obs_soy - mean(obs_soy))^2)
r2 <- 1 - (ss_res / ss_tot)

nrmse <- rmse/mean(obs_soy)

nse <- 1 - (sum((obs_soy - pred_soy)^2) / sum((obs_soy - mean(obs_soy))^2))

plot(cit_soy)

# extract p-values
pvals <- unlist(nodeapply(cit_soy, ids = nodeids(cit_soy), function(n) info_node(n)$p.value))
pvals <- pvals[pvals <.05]
# plotting
ggparty(cit_soy) +
  geom_edge() +
  geom_edge_label() +
  geom_node_label(line_list = list(aes(label = splitvar),
                                   aes(label = paste0("N=", nodesize, ", p", 
                                                      ifelse(pvals < .001, "<.001", paste0("=", round(pvals, 3)))), 
                                       size = 10)),
                  line_gpar = list(list(size = 13), 
                                   list(size = 10)), 
                  ids = "inner") +
  geom_node_label(aes(label = paste0("Node ", id, ", N = ", nodesize)),
    ids = "terminal", nudge_y = -0.0, nudge_x = 0.01) +
  geom_node_plot(gglist = list(
    geom_bar(position = position_fill(), color = "black"),
      theme_minimal(),
      scale_fill_manual(values = c("gray50", "gray80"), guide = FALSE),
      scale_y_continuous(breaks = c(0, 1)),
    xlab(""), 
    ylab("Mean soy yield (Mg/ha"),
    shared_axis_labels = TRUE))

ggparty(cit_soy) +
  geom_edge() +
  geom_edge_label() +
  geom_node_splitvar(aes(label = splitvar),
                     ids = "inner") +
  geom_node_label(aes(label = info),
                  ids = "terminal")


soy_nt <- soy_rye_std %>%
  mutate(SoySeedingDate = as.Date(SoySeedingDate, format = "%m/%d/%y")) %>%
  left_join(all_plant_prcp) %>%
  filter(Till_NT == "NT") %>%
  mutate(pdoy = yday(SoySeedingDate),
         WeedBiomass_kgha = as.numeric(WeedBiomass_kgha),
         Till_NT = as.factor(Till_NT),
         State = as.factor(State),
         exp_treat = as.factor(ExperimentalTrt)) %>% 
  filter(Year < 2024) %>%
  dplyr::select(Year,State, Till_NT, Yield_Mgha, plant_prcp, RyeBiomass_kgha) %>%
  mutate(year_fac = as.factor(Year)) %>%
  drop_na()

cit_nt <- ctree(Yield_Mgha ~ State + plant_prcp + RyeBiomass_kgha, data = soy_nt)
plot(cit_nt)

stand_w_prcp <- filter_w_stand %>%
  left_join(all_plant_prcp)

stand_tree <- ctree(Yield_Mgha ~ as.factor(Till_NT) + plant_prcp + Per_Emergence, data = stand_w_prcp)
plot(stand_tree)
```

```{r Saxton and Rawls Pedotransfer Function}
#### Function to estimate field capacity (theta 33 kpa) and wilting point (theta 1500 kpa) from soil textural data. 
#### Equations from Saxton and Rawls 2006 paper Soil Water Characteristic Estimates by Texture and Organic Matter for Hydrologic Solutions

sax_rawl_fc_wp <- function(sand, silt, clay, org_mat = 0.03){
  theta_1500t <- (-0.024*sand)+(0.487*clay)+(0.006*org_mat)+(0.005*(sand*org_mat))-(0.013*clay*org_mat)+(0.068*clay*sand)+0.031
  theta_1500 <- theta_1500t + ((0.14*theta_1500t)-0.02)
  
  theta_33t <- (-0.251*sand)+(0.195*clay)+(0.011*org_mat)+(0.006*sand*org_mat)-(0.027*clay*org_mat)+(0.452*sand*clay)+0.299
  theta_33 <- theta_33t + (1.283*(theta_33t)^2-0.374*theta_33t-0.015)
  
  soil_wat_df <- data.frame(theta_1500, theta_33)
  return(soil_wat_df)
}

sax_rawl_fc_wp(sand = 0.26, silt = 0.55, clay = 0.19, org_mat = 0.035)
```

```{r OCS Soil Moisture Data}
ocs_vwc <- read_csv("~/Downloads/ocs_soilmoist_june25.csv")

ocs_vwc$channel_name[ocs_vwc$sensor_sn == "21978491-1"] <- "Soil water content (m³/m³) Zone 1"
ocs_vwc$channel_name[ocs_vwc$sensor_sn == "21978491-2"] <- "Soil water content (m³/m³) Zone 2"
  
ocs_vwc_upd <- ocs_vwc %>%
  separate_wider_delim(alias, delim = "-", names = c("plot", "mgmt")) %>%
  mutate(plot = trimws(plot)) %>%
  mutate(crop = case_when(
    endsWith(plot,"A") ~ "Corn",
    endsWith(plot,"B") ~ "Soybean"
  )) %>%
  mutate(date = as.POSIXct(time, format = "%m/%d/%y %H:%M"),
         month = month(date),
         day = day(date)) %>%
  group_by(month, day, sensor_sn) %>%
  mutate(avg_daily_vwc = mean(value))

ocs_vwc_upd %>%
  ggplot(aes(x = day, y = avg_daily_vwc, colour = plot, linetype = mgmt)) +
  geom_line() +
  facet_wrap(crop~channel_name) +
  theme_pubr() +
  labs(linetype = "", colour = "", y = "Average Daily VWC (mm/mm)",
       x = "Day of June 2025")


```

